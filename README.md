# rusty_elma

//////////////////////////////////////// Note on Organization //////////////////////////
Please note the following organization. For grading purposes I have left in the goals and milestones previously written, but you will find them all the way at the bottom of this README.

//////////////////////////////////// An intro to Rusty Elma /////////////////////////////
Rusty Elma aims to be a port of the ELMA project written in C++ into the Rust programming language. ELMA is a task management system developed by klavins (see the following link).
https://github.com/klavins/ECEP520
Rusty Elma aims to be a management system wherein one can create different processes, data channels, and events. In the management system of Elma, one can then have all of these sub-systems talk to each other and coexist.

//////////////////////////////////// Using the Code ////////////////////////////////////////
To use the code…
1.	Pull from the repo
2.	Build the docker file with
Docker build -t rust_cont -f rust_interactive.dockerfile .
3.	Run the container with
docker run -it -v $PWD:/source rust_cont bash
4.	Build elma with “Cargo build”
5.	Running the code does nothing since there is no code in main. This would normally be done with “cargo run”
6.	Run all tests cases with output using “cargo test -- --nocapture”
7.	Compile all documentation with “cargo doc”

//////////////////////////////////// Rust directory explanation /////////////////////////////
The first thing to do when creating a rust directory is to use the command
cargo new proj_name –lib
I preferred to use the –lib identifier when doing my project because it creates a lib.rs file in which you can specify which modules to include in a library which gets created at compile time. You can then include this library in other files aka the separate test directory.
From the main repo directory you will see a few important sub-directories. The ones of interest are “src”, “docs”, “test”.
The src directory contains all the source files which make up ELMA. This is all the actual code which gets compiled into the ELMA library. There is further documentation on the src files in the src directory.
The test directory is where all the unit tests are placed. Rust knows to look in this test subdirectory for extra tests, though they could be placed in the src directory as well. I have followed the method of keeping all tests in this test directory and separating them from the source files. This keeps the directory clean, the files shorter, and prevents including unwanted things in the compiled ELMA library.
The docs directory contains all the documentation for the project. One can use the built in command…
Cargo doc
This will create documentation based on the directory structure and the comments placed in the code. This is placed in the target directory, which is ignored by the gitignore, but I have pulled it out and checked in the final comments for easy viewing.
The comment structure is similar to doxygen. If you look in the docs folder you can find a really nice html file which is great for navigating the code and has all my rust comments, but unfortunately I had a hard time integrating that with github-pages. The github-pages did not play nicely with the html generated by Rust.

//////////////////////////// Rust Learnings and Explanation /////////////////////////////
The first thing of interest when coming into Rust from doing C and C++ is to find corollaries with the other languages. To me, there are a few problems to solve in the porting.
1.	Equivalent of classes
To start, classes don’t exist in Rust. There are also no global variables. The question then becomes how do we share data with certain functions.
One must create a struct and impl of the same name. This can be seen below…
pub struct classReplacer {
  pub data : u64,
}

Impl classReplacer {
  fn first_func(&self)->u64 { return self.data }
}

In the example above, the newly created impl(implementation) contains functions which can access data declared by the struct of the same name. It accesses these fields through the passed in self variable which can be likened to the this variable in C++. Fields can not be stored in the impl, so you must follow this structure to utilize fields within functions unless they are explicitly passed in from higher functions.

2.	Inheritance and porting of classes
To start, there is no inheritance in the classical C++ sense. In order to achieve this in Rust, one must create traits which can then be implemented into modules. See below for an example…
pub trait classTrait {
      fn func1(&self);
    fn func2(&mut self) {
        other_mod::otherfunc(self);
    }
}

This trait contains functions to be used elsewhere. If used in a different implementation, it ensures a few things. It enforced that the new implementation must contain these functions. If the implementation already exists like with func2, then it doesn’t need reimplemented. You may reimplement func2, however, in which case the function is overshadowed by the new implementation. This is very like virtual functions in C++.
With func1, however, since it doesn’t have an implementation, you must declare the implementation in the impl. See below for an example of using this trait…

pub struct classReplacer {
  pub data : u64,
}

Impl classTrait for classReplacer {
      fn func1(&self) { return self.data }
}

One can then call…
classReplacer::func1(input_data);
classReplacer::func2(input_data);


3.	Managing data
Data ownership is the core of Rust. To keep things simple, data is owned by one object at a time. If you want another object to use that data you must either pass ownership of lend the data, aka the other object is borrowing it.
This has implications in ELMA. You create processes, channels, and the manager in the main task, so it owns all of them. This means that if you want to the manager to utilize processes and channels you must either give the manager ownership of them or lend them to the manager constantly.
If you lend the processes and channels to ELMA, it clutters the syntax and becomes more complex in how to lend data between functions. For this reason, when adding channels and scheduling processes in the manager, it transfers ownership of those processes and channels to the manager to use as it pleases. This is why in the manager code you will find the following fields…
    pub _processes : Vec<Box<Process>>
    pub _channels : Vec<Box<Channel>>
These allow for storage of the data once given ownership. The size and speed don’t suffer given how a vector of boxes is stored in memory, but rather it syntactically ensures that there are no race conditions with the shared data.
From here, since these are now owned as fields of the manager, we can use them in other manager functions like the update routine. We then call other process update functions from the manager. When calling process functions, the manager lends the channel data to the processes rather than giving ownership since it happens so often and this would likely be an unnecessary speed decrease.

4.	Test infrastructure
The test infrastructure was rather easy in rust. Normally in the code you call your functions of interest, but with testing, as long as you mark above a function with the macro
#[test]
…it will get run as a unit test. You can execute all tests through the command line with…
cargo test
Rust then knows to look for all functions marked with this macro as well as to check every file in the src and test directories. If using the test directory, you need to make sure to include the following…
#[cfg(test)]
extern crate elma_builder;
This tells cargo that this file is being used for test and we import the external crate which we have created from the src directory. In this case, our library is named “elma_builder”.

///////////////////////////////// Recommended Resources /////////////////////////////
-	The book, "Programming Rust: Fast, Safe Systems Development" was essential for me. I would not have been able to do this project without sitting down and reading this book (As of the project deadline I am about 200 pages in).
-	https://doc.rust-lang.org/std/
The rust crate documentation is amazing.
-	https://blog.jawg.io/docker-multi-stage-build/
This helped me get off the ground in using Rust with Docker
-	https://facility9.com/2016/05/writing-documentation-in-rust/
This was a nice simple intro to the Rustdocs comments system in rust
-	https://doc.rust-lang.org/book/index.html
This online documentation of Rust is superb
-	http://squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html
Found this one very nice post on ownership and the pointers in Rust


   Week 1 of final project -
 
///////////////////////////////////////// Milestones /////////////////////////////////////////
1. Study Rust equivalents from C and C++. I aim to find the apprioriate ways to handle memory, do basic print debug, and what the structure types are in Rust.
Deadline - 3/9/2019
2. Implement and test Rust implementation of ELMA processes.
Deadline - 3/10/2019
3. Implement and test Rust implementation of ELMA Manager.
Deadline - 3/11/2019
4. Recreate ELMA example of a car wuth cruise control. This will control a cars speed as the desired speed is changed.
Deadline - 3/11/2019
5. Implement events in the rust version of Elma.
Deadline - 3/16/2019
6. Use the emit and watch functionality of Elma written in Rust to test the new event system
Deadline - 3/16/2019
7. Create the Rust equivalent of a state machine class
Deadline - 3/18/2019
8. Create a new state machine in Rust to model a microwave.
Deadline - 3/18/2019
9. Clean doxygen documentation and publish it as the github pages.
Deadline - 3/20/2019
10. Finalize and publish project
Deadline - 3/21/2019


Week 2 of final project -

////////////////////////////// Finished goals //////////////////////////////////
This week I accomplished a couple things.
- I did a lot of studying of Rust. This took quite a bit of time given it is a new language. I made it through quite a bit of the Programming rust book I mentioned before, which allowed me to get a good running start at the code.
- I got the channels working for ELMA in Rust. I forgot to take this into account in the milestones, so I should have made time for that first. I am not fully done with the testing of this functionality and it works as expected.
- I have begun implementing the Processes and Manager of ELMA, but still need to test them.
- I figured out the proper way to test code in Rust

////////////////////////////Working Code ////////////////////////////////////
To see the current working code you can navigate into src/main.rs
The main file contains a general stopwatch module and tests for all the other pieces of ELMA. I have properly implemented the test for channels which can be seen as...
#[test]
fn test_channel()
In Rust, all functions marked with the test macro are run as tests when you run "cargo test". This testing tests all the basic functions.

/////////////////////////////// Adjustments to goals /////////////////////////////
With these things in mind, I still think the milestones given are achievable though the dates are skewed. I did not have as much time last week as I hoped I would, but that was mainly because it took me extra time to learn the language. I now feel more confident in the language, however, and think most of the rest can be done in short order. I am thinking if anything of dropping the state machine in order to spend a good amount of time properly documenting using Rust and Github.

/////////////////////////////// Remaining Milestones ////////////////////////////////////////
1. Implement and test Rust implementation of ELMA processes.
Deadline - 3/17/2019
2. Implement and test Rust implementation of ELMA Manager.
Deadline - 3/17/2019
3. Recreate ELMA example of a car wuth cruise control. This will control a cars speed as the desired speed is changed.
Deadline - 3/18/2019
4. Implement events in the rust version of Elma.
Deadline - 3/19/2019
5. Use the emit and watch functionality of Elma written in Rust to test the new event system
Deadline - 3/19/2019
6. Clean doxygen documentation and publish it as the github pages.
Deadline - 3/20/2019
7. Finalize and publish project
Deadline - 3/21/2019


Finalized Final Project -
/////////////////////////////// Unfinished Milestones ////////////////////////////////////////
1. Implement events in the rust version of Elma.
2. Use the emit and watch functionality of Elma written in Rust to test the new event system

/////////////////////////////// Comments on Goals Achieved ////////////////////////////
Throughout this project I thought I would finish up through the events system with emit and watch in Rusty Elma. I was a little over ambitious in my goals, but I am still very pleased with what I got done.
The issue, was that for me personally there was a larger learning curve to Rust than anticipated. My initial thoughts were that I would jump in and it would be enough like C and C++ to just plow out the code. As it turns out, though there are many similarities to the languages in the syntax, the overarching rules and design stratagems are completely different. As a consequence, I wrote out the channel system, process system, and manager system in isolation, then when I went to integrate them they needed a full redesign. The issue is that Elma relies on sharing information between channels, processes, and manager through pointers to the classes. In Rust, while possible, this is not good Rust practice. You can believe me, I tried with all my might to break the compiler. I sincerely attempted to create unsafe C pointers, declare them as reference counters, assign them to other objects dynamically, pass them into other functions, and dereference them there. The compiler still caught my unsafe practices and prevented me from doing what I needed. Then I redesigned.
It took me two full redesigns and a lot more research into Rust to piece together an appropriate way to store the processes and channels within the manager using the box system. Then lending information between sub-systems became reasonable. This, along with plenty of other small learnings in the language surprised me.
In the end there are two large takeaways for me. The first is that one should come into learning a new language paying more attention to the paradigms set forth for that language. The second is that I love Rust. It has all the benefits of C, with the addition of some major improvements in C++, but alleviates all the huge issues with both languages. I can already say that through doing Rust it has made me think about how I write C on a daily basis.
Thought I did not manage to get as far as intended, I learned far more about the language than anticipated and I very much like it. In addition, while I will first allow the grading process to occur, I will likely continue iterating on this project just because I think its fun. I eventually want to learn enough Rust to use it in embedded systems, which requires I do far more work into learning how to use external system, unsafe systems, how to integrate interrupts, etc.
